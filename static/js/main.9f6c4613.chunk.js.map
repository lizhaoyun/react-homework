{"version":3,"sources":["toDoList/Todoing.js","toDoList/Toinput.js","toDoList/ToDoList.js","index.js"],"names":["Todoing","this","props","dol","del","map","item","idx","key","onClick","e","Component","defaultProps","todo","Toinput","handleInput","keyCode","add","target","value","handleChange","setState","name","parseInt","bind","state","a","b","c","refs","focus","ref","inp","onChange","type","onKeyDown","console","log","ToDoList","addItem","data","delItem","event","splice","obj","o","Object","assign","keys","forEach","ReactDOM","render","document","getElementById"],"mappings":"qPAGqBA,E,iLAMP,IAAD,EACWC,KAAKC,MAAhBC,EADA,EACAA,IAAIC,EADJ,EACIA,IACT,OACK,4BAEOD,EAAIE,KAAI,SAACC,EAAKC,GAKV,OAAO,wBAAIC,IAAKD,GAAMD,EAAf,OAAwB,4BAAQG,QAAS,SAACC,GAAKN,EAAIG,EAAIG,KAA/B,yB,GAhBlBC,aAmCrCX,EAAQY,aAAa,CACjBC,KAAK,CAAC,EAAE,GAAG,I,mBCrCMC,E,YAoBjB,aAAc,IAAD,8BACT,+CAQJC,YAAY,SAACL,GAEQ,KAAdA,EAAEM,SAED,EAAKd,MAAMe,IAAIP,EAAEQ,OAAOC,QAbnB,EAgBbC,aAAa,SAACV,GACV,EAAKW,SAAL,eAEKX,EAAEQ,OAAOI,KAAMC,SAA0B,KAAjBb,EAAEQ,OAAOC,MAAW,EAAET,EAAEQ,OAAOC,UAjB5D,EAAKJ,YAAY,EAAKA,YAAYS,KAAjB,gBACjB,EAAKC,MAAM,CACPC,EAAE,GACFC,EAAE,GACFC,EAAE,IANG,E,iFAyBT3B,KAAK4B,KAAKF,EAAEG,U,+BAEN,IAAD,OACL,OACI,4BAGI,2BAAOC,IAAK,SAACC,GAAO,EAAKN,EAAEM,GAAMV,KAAK,IAAIW,SAAUhC,KAAKmB,aAAcD,MAAOlB,KAAKwB,MAAMC,EAAIQ,KAAK,OAAOC,UAAWlC,KAAKc,cAH7H,IAKI,2BAAOgB,IAAI,IAAIT,KAAK,IAAIW,SAAUhC,KAAKmB,aAAcD,MAAOlB,KAAKwB,MAAME,EAAIO,KAAK,OAAOC,UAAWlC,KAAKc,cAL3G,IAOI,2BAAOO,KAAK,IAAIW,SAAUhC,KAAKmB,aAAcD,MAAOlB,KAAKwB,MAAMG,EAAIM,KAAK,OAAOC,UAAWlC,KAAKc,cAPnG,IASI,2BAAId,KAAKwB,MAAMC,EAAEzB,KAAKwB,MAAME,EAAE1B,KAAKwB,MAAMG,GACzC,2BAAOM,KAAK,OAAOZ,KAAK,IAAIS,IAAK,SAACC,GAAO,EAAKA,IAAIA,KAOlD,4BAAQvB,QAAS,WAAK2B,QAAQC,IAAI,EAAKL,OAAvC,qB,GAlEqBrB,aCEhB2B,E,YACjB,aAAc,IAAD,uBACT,+CAuBJC,QAAQ,SAACC,GACLJ,QAAQC,IAAIG,GACZ,EAAKnB,SAAS,CACVR,KAAK,GAAD,mBAAK,EAAKY,MAAMZ,MAAhB,CAAqB2B,OA3BpB,EA8BbC,QAAQ,SAACjC,EAAIkC,GAOTN,QAAQC,IAAIK,EAAMxB,QAClB,IAAIL,EAAI,YAAO,EAAKY,MAAMZ,MAC1BA,EAAK8B,OAAOnC,EAAI,GAChB,EAAKa,SAAS,CACVR,KAAKA,IACP,WACEuB,QAAQC,IAAI,EAAKZ,MAAMZ,UAzC3B,EAAKY,MAAM,CACPZ,KAAK,CAAC,EAAE,EAAE,IAMd,IAAI+B,EAAM,CAAClB,EAAE,IAAIC,EAAE,CAAC,EAAE,EAAE,IAKpBkB,EAAIC,OAAOC,OAAOH,EAJZ,CAAChB,EAAE,MAVJ,OAiBTQ,QAAQC,IAAIQ,IAAMD,GAClBE,OAAOE,KAAKJ,GAAKK,SAAQ,SAAA3C,GACtB8B,QAAQC,IAAI/B,GACZ8B,QAAQC,IAAIO,EAAItC,OApBV,E,sEAqDT,OACI,6BACI,kBAAC,EAAD,CAASW,IAAKhB,KAAKsC,UACnB,kBAAC,EAAD,CAASpC,IAAKF,KAAKwB,MAAMZ,KAAMT,IAAKH,KAAKwC,e,GAzDnB9B,aCItCuC,IAASC,OAAO,kBAAC,EAAD,MAAYC,SAASC,eAAe,W","file":"static/js/main.9f6c4613.chunk.js","sourcesContent":["import React,{Component}from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default class Todoing extends Component{\r\n\r\n    // delItem(idx,e){\r\n    //     console.log(e);\r\n    //     this.props.del(idx,e);\r\n    // }\r\n    render() {\r\n        var {dol,del} = this.props;\r\n        return (\r\n             <ul>\r\n                {   //里面是一个值,非语句\r\n                    dol.map((item,idx)=>{\r\n                        /**\r\n                         *  受控组件：\r\n                         *      value值被react控制的表单元素\r\n                         */\r\n                        return <li key={idx}>{item}----<button onClick={(e)=>{del(idx,e)}}>删除</button></li>\r\n                        // return <li key={idx}>{item}----<button onClick={this.delItem.bind(this,idx)}>删除</button></li>\r\n\r\n                    })\r\n                }\r\n                 \r\n             </ul>\r\n        );\r\n    }\r\n}\r\n\r\nTodoing.propTypes={\r\n    todo:PropTypes.array,\r\n    del:PropTypes.func\r\n}\r\n\r\n/**\r\n *  设置默认值\r\n */\r\nTodoing.defaultProps={\r\n    todo:[1,12,3]\r\n}","import React, { Component } from 'react'\r\n\r\nexport default class Toinput extends Component {\r\n\r\n    /**\r\n    *  受控组件：\r\n    *      value值被react控制的表单元素\r\n    * \r\n    *   可实现获取表单元素的值(表单验证)/\r\n    */\r\n\r\n\r\n    // constructor(){\r\n    //     super();\r\n    //     this.handleInput = this.handleInput.bind(this); //bind将当前类的this，指向父类的this\r\n    // }\r\n    // handleInput(e){  //自己声明的不会自动执行,并且拿不到this\r\n    //     if(e.keyCode === 13){   //按下回车的情况。 按照每个键对应的键值判断，是否为回车\r\n    //         console.log(e.target.value);  //e.target代表当前触发事件的input结点\r\n    //         this.props.add();\r\n    //     }\r\n    // }\r\n    constructor(){\r\n        super();\r\n        this.handleInput=this.handleInput.bind(this);\r\n        this.state={\r\n            a:\"\",\r\n            b:\"\",\r\n            c:\"\"\r\n        }\r\n    }\r\n    handleInput=(e)=>{  \r\n        //绑定this，事件处理函数写成箭头函数\r\n        if(e.keyCode === 13){\r\n            // console.log(e.target.value);  \r\n            this.props.add(e.target.value);\r\n        }\r\n    }\r\n    handleChange=(e)=>{\r\n        this.setState({\r\n            // inputValue:e.target.value\r\n            [e.target.name]:parseInt(e.target.value===''?0:e.target.value)\r\n        })\r\n    }\r\n    componentDidMount(){\r\n\r\n        // this.a.focus();\r\n        this.refs.b.focus();  //ref=“b”   时，字符串作为refs的属性名，属性值为当前ref所在的结点\r\n    }\r\n    render() {\r\n        return (\r\n            <ul>\r\n                \r\n                {/* <input type='text' onKeyDown={()=>{console.log(1)}}></input> */}\r\n                <input ref={(inp)=>{this.a=inp}} name=\"a\" onChange={this.handleChange} value={this.state.a}  type='text' onKeyDown={this.handleInput}></input>\r\n                +\r\n                <input ref=\"b\" name=\"b\" onChange={this.handleChange} value={this.state.b}  type='text' onKeyDown={this.handleInput}></input>\r\n                +\r\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c}  type='text' onKeyDown={this.handleInput}></input>                \r\n                =\r\n                <p>{this.state.a+this.state.b+this.state.c}</p>\r\n                <input type='text' name=\"d\" ref={(inp)=>{this.inp=inp}}></input>   \r\n                {/**\r\n                    ref方法将获取到的标签结点的引用赋给形参，可将次属性写在this上属性，别的地方可以直接访问该结点\r\n\r\n                    非受控组件：\r\n                    一次性处理表单元素的值，ref直接拿到结点\r\n                */}     \r\n                <button onClick={()=>{console.log(this.inp)}}>提交</button>\r\n            </ul>\r\n        )\r\n    }\r\n}\r\n\r\n/**\r\n *  受控组件：\r\n *    1.给input小钱加value属性，赋值为state的值\r\n *    2.给input标签绑定onChange事件，\r\n *    在事件处理函数中setState\r\n *    3.一个事件处理函数控制多个表单元素时，\r\n *      给input标签加上name属性，时间处理函数中写：\r\n *      setState({[e.target.name]:e.target.value})\r\n */\r\n","import React, { Component } from 'react';\r\nimport Todoing from './Todoing';\r\nimport Toinput from './Toinput';\r\n\r\nexport default class ToDoList extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            todo:[1,2,3]\r\n        }\r\n\r\n         /**\r\n         *  深拷贝---浅拷贝\r\n         */\r\n        var obj = {a:100,b:[1,2,3]};\r\n        var obj1 ={c:300};\r\n        // var o = obj;\r\n        // var o = {...obj};\r\n        // var o = JSON.parse(JSON.stringify(obj));\r\n        var o = Object.assign(obj,obj1);        //合并。合并到谁身上就先写谁。\r\n        // var o = Object.assign({},obj,obj1);  生成新的对象\r\n        // o.b[0] = 200;   //obj内层依旧是浅拷贝。obj的b和o的b指向相同\r\n        console.log(o === obj);     //true\r\n        Object.keys(obj).forEach(item => {\r\n           console.log(item);\r\n           console.log(obj[item]); \r\n        });\r\n\r\n    }\r\n    addItem=(data)=>{  //子组件向父组件传数据，应用父组件给子组件传函数实现\r\n        console.log(data);\r\n        this.setState({\r\n            todo:[...this.state.todo,data]\r\n        })\r\n    }\r\n    delItem=(key,event)=>{\r\n\r\n    /**\r\n     *  1.不能直接改变或处理state，通过setState改变\r\n     *  2.setState是异步执行\r\n     */\r\n\r\n        console.log(event.target);\r\n        let todo = [...this.state.todo];\r\n        todo.splice(key,1);   //可删除/添加任意一项\r\n        this.setState({\r\n            todo:todo\r\n        },()=>{\r\n            console.log(this.state.todo);\r\n        })\r\n\r\n        // this.setState((state,props)=>{  //state拿到执行之前的值     props：拿到当前需要的props属性\r\n        //     return {\r\n        //         todo:todo\r\n        //     }\r\n        // })\r\n    }\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Toinput add={this.addItem}/>      \r\n                <Todoing dol={this.state.todo} del={this.delItem}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","// import React from 'react';\nimport React,{Fragment,Component}from 'react';    //直接引入Fragment。\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import ShowTime from \"./ShowTime.js\";\nimport ToDoList from './toDoList/ToDoList';\n// import App from './App';\n\nReactDOM.render(<ToDoList/>,document.getElementById('root'));\n\n/**\n *  10-9 ch02\n */\n\n//显示当前系统时间\n// function show(){\n//     //只会渲染不一样的地方。\n//     var ele = <div>{new Date().toLocaleString()}</div>; //一旦创建，属性不可改变\n//     ReactDOM.render(ele,document.querySelector('#root'));\n// }\n//setInterval(show,1000)        将函数体交给setInterval循环执行； show()：将返回值给setInterval，循环执行\n// setInterval(()=>{\n//     show();\n// },1000);\n\n    /**\n     *      组件\n     */\n//1.函数定义组件    函数名首字母大写\n// var num = 20;\n// function ShowTime(props){   //参数为只读,是个对象\n//     return (        //返回内容多时加(),返回的只能是一个元素(一个闭合标签)，内容多时拼成一个返回\n//         // <div>\n//         //     <div>{props.name}{props.age}</div>\n//         //     <div>{new Date().toLocaleString()}</div>\n//         // </div>\n\n//         /**\n//          *  <React.Fragment></> 仅起到包裹作用，不添加到DOM结构中\n//          */\n//         //直接引入fragment后，可写为<Fragment></Fragment>\n//         <Fragment>      \n//             <div>{props.name}{props.age}</div>\n//             <div>{new Date().toLocaleString()}</div>\n//         </Fragment>\n        \n//     )\n// }\nvar num=[1,2,3];\n\n//2.用类定义组件      尽量少用类\n\n// ReactDOM.render(<ShowTime name=\"zhang\" age={num}/>,document.getElementById('root'));   //以标签的形式调用组件\n/**\n *  组件交互\n *  父组件->子组件：调用子组件时添加属性，子组件通过props(函数为props，类为this.props)拿到传递的\n *  子组件->父组件\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n// var str = 'react';\n// var obj={\n//     type:\"div\",\n//     props:{\n//         class:\"hi\",\n//         children:[  //描述react标签的内容\n//             'hello',\n//             'react',\n//             {\n//                 type:\"h1\",\n//                 props:{\n//                     class:\"pp\",\n//                     children:[  //描述react标签的内容\n//                         'title',\n//                         'react',\n//                         'dsjakfnkj',\n//                         {\n//                             type:\"h5\",\n//                             props:{\n//                                 class:\"yy\",\n//                                 children:[  //描述react标签的内容\n//                                     'I',\n//                                     'up',\n//                                     '❤',\n//                                 ]\n//                             }\n//                         }\n//                     ]\n//                 }\n//             }\n//         ]\n//     }\n// }\n// var ele = <h1 class=\"hi\">hello {str}</h1>      //遇到 < 会把后面的内容转化为对象\n\n// var ele = React.createElement(\n//     \"h1\",{id:'hh',class:'pp'},'hello',\n//     React.createElement(\"p\",{id:'hh',class:'pp'},'react')\n// );\n// ReactDOM.render(ele, document.getElementById('root'));      //ele实际传入的是对象\n\n\n//自己封装render(渲染函数)\n// function render(obj,container){\n//     var {type,props} = obj;\n\n//     /**\n//      *  文档碎片    存在内存中的变量。类似虚拟的dom结点。多次dom操作保存，最后一次渲染。\n//      *  \n//      *  页面重绘(repaint)：除引起回流的事件外，如：颜色变化(背景色、字体颜色、边框颜色)\n//      *  页面回流(重排reflow)：dom结构变化、内容变化、大小、位置变化会引起       代价大，浏览器会执行一些操作\n//      * \n//      *  回流一定会引起重绘\n//      */\n\n//     //原因： 页面展现过程\n//     /**\n//      *  请求HTML页面，浏览器HTML解析器会解析html文件，生成dom树\n//      *  link引入css文件，css解析器解析css，生成css对象模型(css规则)--CSSOM,\n//      *  CSSOM和DOM树结合生成一个render tree(渲染树)--最终呈现的内容，\n//      *  最后浏览器会绘制页面进行呈现\n//      */\n//     var fragment = document.createDocumentFragment();\n\n\n//     var ele = document.createElement(type); //虚拟dom\n//     for (var key in props) {\n//         if(key === 'class'){\n//             ele.className = props[key];\n//         }else if(key === 'children'){   //children是子元素，不在其属性上\n//             for(var i=0;i<props.children.length;i++){\n//                 if(typeof props.children[i] === 'object'){\n//                     render(props.children[i],ele);\n//                 }else{\n//                     var txt = document.createTextNode(props.children[i]);\n//                     ele.appendChild(txt);\n//                 }\n//             }\n//         }else{\n//             ele[key] = obj.props[key];    // . 访问，仅访问名字；[]访问\n//         }\n//     }\n//     fragment.appendChild(ele);\n//     container.appendChild(fragment);\n//     // container.appendChild(ele);\n// }\n\n// render(obj,document.getElementById('root'));\n\n/**\n * ------------------------- 性能提升-------------------\n */\n\n//1.先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var str ='';\n// var div = document.getElementById(\"root\");\n// for(var i=0;i<1000;i++){\n//     str += '<p>'+i+'</p>';\n// }\n// div.innerHTML +=str;\n// console.timeEnd(\"time\");\n\n\n//2.样式处理\n//在css中声明一个css类\n// var div =document.getElementById(\"root\");\n// div.style.width=\"100px\";\n// div.style.height = '100px';\n// div.style.backgroundColor=\"red\";\n/**\n *  .active{\n *      width:100px;\n *      height:100px;\n *      background:red;\n * }\n * div.className = 'active';\n */\n// div.className = 'active';\n\n\n//3.offsetLeft、offsetRight、offsetWidth、offsetHeight 等都会引起回流\n// var wid = div.offsetWidth;\n// setInterval(()=>{\n//     wid+=1;\n//     div.style.width = wid+\"px\";\n//     // div.style.width = (div.offsetWidth+1)+\"px\";\n// },1000)\n\n//4.文档碎片\n\n\n\n\n"],"sourceRoot":""}